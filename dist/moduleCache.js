import{watch}from"fs";import path from"path";export default class ModuleCache{constructor(config={}){this.cache=new Map,this.watchers=new Map,this.maxSize=config.maxSize||100,this.maxMemoryMB=config.maxMemoryMB||50,this.ttlMs=config.ttlMs||3e5,this.maxHeapUsagePercent=config.maxHeapUsagePercent||70,this.memoryCheckInterval=config.memoryCheckInterval||3e4,this.watchFiles=!1!==config.watchFiles,this.currentMemoryMB=0,this.stats={hits:0,misses:0,evictions:0,fileChanges:0},!1!==config.enableMemoryMonitoring&&this.startMemoryMonitoring()}startMemoryMonitoring(){this.memoryTimer=setInterval(()=>{const usage=process.memoryUsage(),heapPercent=usage.heapUsed/usage.heapTotal*100;if(heapPercent>this.maxHeapUsagePercent){const clearedCount=this.clearExpiredEntries();for(this.stats.evictions+=clearedCount;this.cache.size>0&&heapPercent>this.maxHeapUsagePercent;)this.evictOldest()}},this.memoryCheckInterval)}destroy(){this.memoryTimer&&clearInterval(this.memoryTimer);for(const watcher of this.watchers.values())watcher.close();this.watchers.clear(),this.cache.clear()}get(filePath,stats){const entry=this.cache.get(filePath);if(!entry)return this.stats.misses++,null;return Date.now()-entry.timestamp>this.ttlMs||entry.mtime<stats.mtime?(this.delete(filePath),this.stats.misses++,null):(this.cache.delete(filePath),this.cache.set(filePath,entry),this.stats.hits++,entry.module)}set(filePath,module,stats,estimatedSizeKB=1){const sizeInMB=estimatedSizeKB/1024;for(;this.cache.size>=this.maxSize||this.currentMemoryMB+sizeInMB>this.maxMemoryMB;)this.evictOldest();const entry={module:module,mtime:stats.mtime,timestamp:Date.now(),sizeKB:estimatedSizeKB,filePath:filePath};this.cache.set(filePath,entry),this.currentMemoryMB+=sizeInMB,this.watchFiles&&this.setupFileWatcher(filePath)}delete(filePath){const entry=this.cache.get(filePath);if(entry){this.cache.delete(filePath),this.currentMemoryMB-=entry.sizeKB/1024;const watcher=this.watchers.get(filePath);return watcher&&(watcher.close(),this.watchers.delete(filePath)),!0}return!1}clear(){const size=this.cache.size;this.cache.clear(),this.currentMemoryMB=0;for(const watcher of this.watchers.values())watcher.close();this.watchers.clear(),this.stats.evictions+=size}evictOldest(){if(0===this.cache.size)return;const[oldestKey,oldestEntry]=this.cache.entries().next().value;this.delete(oldestKey),this.stats.evictions++}clearExpiredEntries(){const now=Date.now();let clearedCount=0;for(const[filePath,entry]of this.cache.entries())now-entry.timestamp>this.ttlMs&&(this.delete(filePath),clearedCount++);return clearedCount}setupFileWatcher(filePath){if(!this.watchers.has(filePath))try{const watcher=watch(filePath,eventType=>{"change"===eventType&&(this.delete(filePath),this.stats.fileChanges++)});watcher.on("error",error=>{this.delete(filePath)}),this.watchers.set(filePath,watcher)}catch(error){console.warn(`Could not watch file ${filePath}: ${error.message}`)}}getStats(){const memoryUsage=process.memoryUsage();return{cache:{size:this.cache.size,maxSize:this.maxSize,memoryUsageMB:Math.round(100*this.currentMemoryMB)/100,maxMemoryMB:this.maxMemoryMB,watchersActive:this.watchers.size},stats:{...this.stats},memory:{heapUsedMB:Math.round(memoryUsage.heapUsed/1024/1024*100)/100,heapTotalMB:Math.round(memoryUsage.heapTotal/1024/1024*100)/100,heapUsagePercent:Math.round(memoryUsage.heapUsed/memoryUsage.heapTotal*100),rssMB:Math.round(memoryUsage.rss/1024/1024*100)/100},config:{ttlMs:this.ttlMs,maxHeapUsagePercent:this.maxHeapUsagePercent,watchFiles:this.watchFiles}}}getHitRate(){const total=this.stats.hits+this.stats.misses;return 0===total?0:Math.round(this.stats.hits/total*100)}logStats(log){const stats=this.getStats();log(`Cache Stats: ${stats.cache.size}/${stats.cache.maxSize} entries, ${stats.cache.memoryUsageMB}/${stats.cache.maxMemoryMB}MB, ${this.getHitRate()}% hit rate`,2)}getCachedFiles(){return Array.from(this.cache.keys()).map(filePath=>({path:filePath,relativePath:path.relative(process.cwd(),filePath),age:Date.now()-this.cache.get(filePath).timestamp,sizeKB:this.cache.get(filePath).sizeKB}))}}